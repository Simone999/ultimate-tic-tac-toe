<div class="notebook">

<div class="nb-cell markdown" name="md1">
## Simple tic tac toe
</div>

<div class="nb-cell program" data-background="true" name="p1">
% Show the tic tac toe board
show([A,B,C,D,E,F,G,H,I]) :- write([A,B,C]),nl,
    							write([D,E,F]),nl,
    							write([G,H,I]),nl,nl.

% Start game helpers
%selfgame :- game([b,b,b,b,b,b,b,b,b],x). %AI vs AI
%playo :- explain, playfrom([b,b,b,b,b,b,b,b,b]). %AI vs human
explain :-
  write('You play X by entering integer positions followed by a period.'),
  nl,
  show([1,2,3,4,5,6,7,8,9]).

set_current_player(Player):- b_setval(player, Player).
current_player(Player):- b_getval(player, Player).

% Facts
player(o).
player(x).

other(x,o). 
other(o,x).

% Terminal state terminal(Board, Winner)
% Check on player(Player) avoids Winner = b
% terminal_state(+Board, -Player)
terminal_state(Board, Player):- player(Player), win(Board, Player), !.
terminal_state(Board, draw):- nomoves(Board).

% Winning conditions:
win(Board, Player) :- rowwin(Board, Player), !.
win(Board, Player) :- colwin(Board, Player), !.
win(Board, Player) :- diagwin(Board, Player), !.

rowwin(Board, Player) :- Board = [Player,Player,Player,_,_,_,_,_,_].
rowwin(Board, Player) :- Board = [_,_,_,Player,Player,Player,_,_,_].
rowwin(Board, Player) :- Board = [_,_,_,_,_,_,Player,Player,Player].

colwin(Board, Player) :- Board = [Player,_,_,Player,_,_,Player,_,_].
colwin(Board, Player) :- Board = [_,Player,_,_,Player,_,_,Player,_].
colwin(Board, Player) :- Board = [_,_,Player,_,_,Player,_,_,Player].

diagwin(Board, Player) :- Board = [Player,_,_,_,Player,_,_,_,Player].
diagwin(Board, Player) :- Board = [_,_,Player,_,Player,_,Player,_,_].


% Move predicates
play(Board, Player, Position, NewBoard, NewPlayer) :-
  	not(terminal_state(Board,_)),
  	move(Board,Player, Position, NewBoard),
  	other(Player, NewPlayer).

move([b,B,C,D,E,F,G,H,I], Player, 1, [Player,B,C,D,E,F,G,H,I]).
move([A,b,C,D,E,F,G,H,I], Player, 2, [A,Player,C,D,E,F,G,H,I]).
move([A,B,b,D,E,F,G,H,I], Player, 3, [A,B,Player,D,E,F,G,H,I]).
move([A,B,C,b,E,F,G,H,I], Player, 4, [A,B,C,Player,E,F,G,H,I]).
move([A,B,C,D,b,F,G,H,I], Player, 5, [A,B,C,D,Player,F,G,H,I]).
move([A,B,C,D,E,b,G,H,I], Player, 6, [A,B,C,D,E,Player,G,H,I]).
move([A,B,C,D,E,F,b,H,I], Player, 7, [A,B,C,D,E,F,Player,H,I]).
move([A,B,C,D,E,F,G,b,I], Player, 8, [A,B,C,D,E,F,G,Player,I]).
move([A,B,C,D,E,F,G,H,b], Player, 9, [A,B,C,D,E,F,G,H,Player]).

nomoves(Board):- not(member(b, Board)).
</div>

<div class="nb-cell query" name="q1">
Board =  [o, x, o,
          b, x, x,
          x, b, b],
show(Board)
</div>

<div class="nb-cell markdown" name="md2">
## Ultimate tic-tac toe
</div>

<div class="nb-cell program" name="p2">

</div>

<div class="nb-cell query" name="q2">

</div>

<div class="nb-cell markdown" name="md4">
## Evaluation function
</div>

<div class="nb-cell program" data-background="true" name="p4">
% eval(+Player, +Node, -Val)
eval(Player, [_, Board], 1):- terminal_state(Board, P), P = Player, !.
eval(_, [_, Board], 0):- terminal_state(Board, P), P = draw, !.
eval(_, [_, Board], -1):- terminal_state(Board, _).
</div>

<div class="nb-cell query" name="q3">
Player = x,
Board =  [o, x, o,
          b, x, x,
          x, x, b],
eval(Player, [nil, Board], V).
</div>

<div class="nb-cell markdown" name="md3">
## MinMax
</div>

<div class="nb-cell program" name="p3">
% Change player while traversing
player_color(max, Player):- current_player(Player).
player_color(min, Other):- 
    current_player(Player),
    other(Player, Other).

swap_max_min(min, max).
swap_max_min(max, min).

% children(+Node, +Player, -Children)
children([_, Board], Player, Children):-
    findall([Move, NewBoard], move(Board, Player, Move, NewBoard), Children).

minimax(Board, BestMove):-
    minimax_step(max, [nil, Board], [BestMove, _], _), !.

% Chooses the best possible move for the current board.
% minimax_step(+MinMax, + Node, -BestNode, -BestValue)
minimax_step(_, [Move, Board], _, BestValue) :-
    terminal_state(Board, _),
    current_player(MaxPlayer),
    eval(MaxPlayer, [Move, Board], BestValue), !.

minimax_step(MinMax, Node, BestNode, BestValue) :-
    player_color(MinMax, Player),
	children(Node, Player, Children),
    best_node(MinMax, Children, BestNode, BestValue), !.

% best_node(+MinMax, +NodeList, -BestNode, -BestValue)
best_node(MinMax, [Node], Node, BestValue) :-   
	swap_max_min(MinMax, Other),
	minimax_step(Other, Node, _, BestValue).
best_node(MinMax, [Node | NodeList], BestNode, BestValue) :-    
	swap_max_min(MinMax, Other),
	minimax_step(Other, Node, _, BottomBestV),
	best_node(MinMax, NodeList, CurrentBestN, CurrentBestV),
	best_of(MinMax, Node, BottomBestV, CurrentBestN, CurrentBestV, BestNode, BestValue).

% best_of(+MinMax, +MoveA, +ValueA, +MoveB, +ValueB, -BetterMove, -BetterValue)
% Chooses the move with the higher value.
best_of(MaxMin, NodeA, ValueA, _, ValueB, NodeA, ValueA) :-
	MaxMin = max, ValueA &gt;= ValueB, !;
    MaxMin = min, ValueA =&lt; ValueB, !.
best_of(_, _, _, NodeB, ValueB, NodeB, ValueB).
</div>

<div class="nb-cell markdown" name="md5">
## Alpha-Beta
</div>

<div class="nb-cell program" name="p5">
% Change player while traversing
player_color(max, Player):- current_player(Player).
player_color(min, Other):- 
    current_player(Player),
    other(Player, Other).

swap_max_min(max, min).
swap_max_min(min, max).

% children(+Node, +Player, -Children)
children([_, Board], Player, Children):-
    findall([Move, NewBoard], move(Board, Player, Move, NewBoard), Children).

% alphabeta(+Board, -BestMove)
alphabeta(Board, BestMove):-
    alphabeta_step(max, [nil, Board], -1000, +1000, [BestMove, _], _), !.

% Chooses the best possible move for the current board.
% minimax_step(+MinMax, + Node, +Alpha, +Beta, -BestNode, -BestValue)
alphabeta_step(_, [Move, Board], _, _, _, BestValue) :-
    terminal_state(Board, _),
    current_player(MaxPlayer),
    eval(MaxPlayer, [Move, Board], BestValue), !.

alphabeta_step(MinMax, Node, Alpha, Beta, BestNode, BestValue) :-
    player_color(MinMax, Player),
	children(Node, Player, Children),
    bounded_best_node(MinMax, Children, Alpha, Beta, BestNode, BestValue), !.

% bounded_best_node(+MinMax, +NodeList, +Alpha, +Beta, -BestNode, -BestValue)
bounded_best_node(MinMax, [Node | NodeList], Alpha, Beta, BestNode, BestValue) :-    
	swap_max_min(MinMax, Other),
	alphabeta_step(Other, Node, Alpha, Beta, _, BottomBestV),
    next_if_good(MinMax, NodeList, Alpha, Beta, Node, BottomBestV, BestNode, BestValue).

% next_if_good(+MinMax, +NodeList, +Alpha, +Beta, +Node, +Value, -BestNode, -BestValue)
next_if_good(_, [], _, _, Node, Value, Node, Value):- !.
% if not good enough -&gt; cutoff
next_if_good(MinMax, _, Alpha, Beta, Node, Value, Node, Value):-
	MinMax = max, Value &gt;= Beta, !;
    MinMax = min, Value =&lt; Alpha, !.
% otherwise go to the next node
next_if_good(MinMax, NodeList, Alpha, Beta, Node, Value, BestNode, BestValue):-
	update_bounds(MinMax, Alpha, Beta, Value, NewAlpha, NewBeta),
    bounded_best_node(MinMax, NodeList, NewAlpha, NewBeta, CurrentBestN, CurrentBestV),
    best_of(MinMax, Node, Value, CurrentBestN, CurrentBestV, BestNode, BestValue).

%update_bounds(+MinMax, +Alpha, +Beta, +Value, -NewAlpha, -NewBeta)
update_bounds(max, Alpha, Beta, Value, Value, Beta):-
    Value &gt;= Alpha, !.
update_bounds(min, Alpha, Beta, Value, Alpha, Beta):-
    Value =&lt; Beta, !.
update_bounds(_, Alpha, Beta, _, Alpha, Beta).

best_of(MinMax, NodeA, ValueA, _, ValueB, NodeA, ValueA) :-
	MinMax = max, ValueA &gt;= ValueB, !;
    MinMax = min, ValueA =&lt; ValueB, !.
best_of(_, _, _, NodeB, ValueB, NodeB, ValueB).
</div>

<div class="nb-cell query" name="q4">
Player = x,
Board =  [o, x, o,
          b, x, x,
          x, b, b]
</div>

</div>
