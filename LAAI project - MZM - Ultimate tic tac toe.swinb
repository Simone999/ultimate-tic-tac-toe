<div class="notebook">

<div class="nb-cell markdown" name="md1">
## Simple tic tac toe
</div>

<div class="nb-cell program" data-background="true" name="p1">
% Show the tic tac toe board
show([A,B,C,D,E,F,G,H,I]) :- write([A,B,C]),nl,
    							write([D,E,F]),nl,
    							write([G,H,I]),nl,nl.

% Start game helpers
selfgame :- game([b,b,b,b,b,b,b,b,b],x). %AI vs AI
playo :- explain, playfrom([b,b,b,b,b,b,b,b,b]). %AI vs human
explain :-
  write('You play X by entering integer positions followed by a period.'),
  nl,
  show([1,2,3,4,5,6,7,8,9]).

% Facts
player(o).
player(x).

other(x,o). 
other(o,x).

% Terminal state terminal(Board, Winner)
% Check on player(Player) avoids Winner = b
terminal(Board, Player):- player(Player), win(Board, Player), !.
terminal(Board, draw):- nomoves(Board).

% Winning conditions:
win(Board, Player) :- rowwin(Board, Player), !.
win(Board, Player) :- colwin(Board, Player), !.
win(Board, Player) :- diagwin(Board, Player), !.

rowwin(Board, Player) :- Board = [Player,Player,Player,_,_,_,_,_,_].
rowwin(Board, Player) :- Board = [_,_,_,Player,Player,Player,_,_,_].
rowwin(Board, Player) :- Board = [_,_,_,_,_,_,Player,Player,Player].

colwin(Board, Player) :- Board = [Player,_,_,Player,_,_,Player,_,_].
colwin(Board, Player) :- Board = [_,Player,_,_,Player,_,_,Player,_].
colwin(Board, Player) :- Board = [_,_,Player,_,_,Player,_,_,Player].

diagwin(Board, Player) :- Board = [Player,_,_,_,Player,_,_,_,Player].
diagwin(Board, Player) :- Board = [_,_,Player,_,Player,_,Player,_,_].


% Move predicates
play(Board, Player, Position, NewBoard, NewPlayer) :-
  	not(terminal(Board,_)),
  	move(Board,Player, Position,  NewBoard),
  	other(Player, NewPlayer).

move([b,B,C,D,E,F,G,H,I], Player, 1, [Player,B,C,D,E,F,G,H,I]).
move([A,b,C,D,E,F,G,H,I], Player, 2, [A,Player,C,D,E,F,G,H,I]).
move([A,B,b,D,E,F,G,H,I], Player, 3, [A,B,Player,D,E,F,G,H,I]).
move([A,B,C,b,E,F,G,H,I], Player, 4, [A,B,C,Player,E,F,G,H,I]).
move([A,B,C,D,b,F,G,H,I], Player, 5, [A,B,C,D,Player,F,G,H,I]).
move([A,B,C,D,E,b,G,H,I], Player, 6, [A,B,C,D,E,Player,G,H,I]).
move([A,B,C,D,E,F,b,H,I], Player, 7, [A,B,C,D,E,F,Player,H,I]).
move([A,B,C,D,E,F,G,b,I], Player, 8, [A,B,C,D,E,F,G,Player,I]).
move([A,B,C,D,E,F,G,H,b], Player, 9, [A,B,C,D,E,F,G,H,Player]).

nomoves(Board):- not(member(b, Board)).
</div>

<div class="nb-cell query" name="q1">

</div>

<div class="nb-cell markdown" name="md2">
## Ultimate tic-tac toe
</div>

<div class="nb-cell program" name="p2">

</div>

<div class="nb-cell markdown" name="md4">
## Heuristic
</div>

<div class="nb-cell program" data-background="true" name="p4">
eval(Player, [_, Board], Val):- Val is 1.
</div>

<div class="nb-cell markdown" name="md3">
## MinMax
</div>

<div class="nb-cell program" data-background="true" name="p3">
set_current_player(Player):- b_setval(player, Player).
current_player(Player):- b_getval(player, Player).

% Change player while traversing
player_color(max, Player):- current_player(Player).
player_color(min, Other):- 
    current_player(Player),
    other(Player, Other).

swap_max_min(min, max).
swap_max_min(max, min).

% children(+Node, +Player, -Children)
children([_, Board], Player, Children):-
    findall([Move, NewBoard], move(Board, Player, Move, NewBoard), Children).

minimax(Board, BestMove):-
    minimax_step(max, [nil, Board], [BestMove, _], _), !.

% Chooses the best possible move for the current board.
% minimax_step(+MinMax, + Node, -BestNode, -BestValue)
minimax_step(MinMax, Node, BestNode, BestValue) :-
    player_color(MinMax, Player),
	children(Node, Player, Children),
    best_node(MinMax, Children, BestNode, BestValue), !.

minimax_step(MinMax, Node, _, BestValue) :-
    player_color(MinMax, Player),
    eval(Player, Node, BestValue).

% best_node(+MinMax, +NodeList, -BestNode, -BestValue)
best_node(MinMax, [Node], Node, BestValue) :-   
	swap_max_min(MinMax, Other),
	minimax_step(Other, Node, _, BestValue).
best_node(MinMax, [Node | NodeList], BestNode, BestValue) :-    
	swap_max_min(MinMax, Other),
	minimax_step(Other, Node, _, BottomBestV),
	best_node(MinMax, NodeList, CurrentBestN, CurrentBestV),
	best_of(MinMax, Node, BottomBestV, CurrentBestN, CurrentBestV, BestNode, BestValue).

% best_of(+MinMax, +MoveA, +ValueA, +MoveB, +ValueB, -BetterMove, -BetterValue)
% Chooses the move with the higher value.
best_of(MaxMin, NodeA, ValueA, _, ValueB, NodeA, ValueA) :-
	MaxMin = max, ValueA &gt;= ValueB, !;
    MaxMin = min, ValueA =&lt; ValueB, !.
best_of(_, _, _, NodeB, ValueB, NodeB, ValueB).



</div>

</div>
